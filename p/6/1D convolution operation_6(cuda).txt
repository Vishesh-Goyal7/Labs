#include <stdio.h>
#include <cuda_runtime.h>

#define WIDTH 8
#define MASK_WIDTH 3

__global__ void convolution1D(int *N, int *M, int *P, int width, int mask_width) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;

    if (i < width) {
        int Pvalue = 0;
        for (int j = 0; j < mask_width; j++) {
            if (i + j < width) {
                Pvalue += N[i + j] * M[j];
            }
        }
        P[i] = Pvalue;
    }
}

int main() {
    int N[WIDTH] = {1, 2, 3, 4, 5, 6, 7, 8};
    int M[MASK_WIDTH] = {1, 2, 3};
    int P[WIDTH];

    int *d_N, *d_M, *d_P;

    cudaMalloc(&d_N, WIDTH * sizeof(int));
    cudaMalloc(&d_M, MASK_WIDTH * sizeof(int));
    cudaMalloc(&d_P, WIDTH * sizeof(int));

    cudaMemcpy(d_N, N, WIDTH * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(d_M, M, MASK_WIDTH * sizeof(int), cudaMemcpyHostToDevice);

    int threadsPerBlock = 256;
    int blocksPerGrid = (WIDTH + threadsPerBlock - 1) / threadsPerBlock;

    convolution1D<<<blocksPerGrid, threadsPerBlock>>>(d_N, d_M, d_P, WIDTH, MASK_WIDTH);

    cudaMemcpy(P, d_P, WIDTH * sizeof(int), cudaMemcpyDeviceToHost);

    printf("Resultant Array P:\n");
    for (int i = 0; i < WIDTH; i++) {
        printf("%d ", P[i]);
    }

    cudaFree(d_N);
    cudaFree(d_M);
    cudaFree(d_P);

    return 0;
}
