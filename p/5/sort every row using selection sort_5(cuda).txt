#include <stdio.h>
#include <cuda_runtime.h>

#define N 3 // Number of rows
#define M 4 // Number of columns

__device__ void selectionSort(int *row, int M) {
    for (int i = 0; i < M - 1; i++) {
        int min_idx = i;
        for (int j = i + 1; j < M; j++) {
            if (row[j] < row[min_idx]) {
                min_idx = j;
            }
        }
        // Swap row[i] and row[min_idx]
        int temp = row[i];
        row[i] = row[min_idx];
        row[min_idx] = temp;
    }
}

__global__ void sortRows(int *matrix, int M) {
    int row = blockIdx.x * blockDim.x + threadIdx.x;
    if (row < N) {
        selectionSort(&matrix[row * M], M);
    }
}

int main() {
    int matrix[N][M] = {
        {9, 7, 5, 1},
        {8, 3, 2, 4},
        {6, 5, 9, 0}
    };
    int *d_matrix;

    cudaMalloc(&d_matrix, N * M * sizeof(int));
    cudaMemcpy(d_matrix, matrix, N * M * sizeof(int), cudaMemcpyHostToDevice);

    int threadsPerBlock = 1;
    int blocksPerGrid = N;

    sortRows<<<blocksPerGrid, threadsPerBlock>>>(d_matrix, M);

    cudaMemcpy(matrix, d_matrix, N * M * sizeof(int), cudaMemcpyDeviceToHost);

    printf("Sorted Matrix:\n");
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }

    cudaFree(d_matrix);
    return 0;
}
